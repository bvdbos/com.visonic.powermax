"use strict";

const pm  = require('./tables.js'),
	  net = require('net'),
	  event = require('events'),
	  handler = require('./handlers.js'),
	  Settings = require('./settings.js');

const MSG_RETRIES = 3;
const PL_RETRIES = 3;
const MAX_CRC_ERROR = 5;
const MAX_IGNORE_DOWNLOAD = 5;
const MAX_RESPONSE_TIME = 10000; // 10 seconds
const TIMEOUT = 40000; // 40 seconds

var debugOn = false;

// Debug logging
function localDebug() {
	if (debugOn) {
		var now = new Date();
		var itemdebug = (x) => { return (typeof x === 'object' ? JSON.stringify(x) : x) + ' ' };
		var time = now.toTimeString().replace(/.*(\d{2}:\d{2}:\d{2}).*/, "$1");
		var ms = ('00' + now.getMilliseconds()).slice(-3);
		var text = '';
		for (var i = 0; i < arguments.length; i++) {
			var x = arguments[i];
			if (Object.prototype.toString.call(arguments[i]) === '[object Arguments]') {
				for (var j = 0; j < x.length; j++) {
					text += itemdebug(x[j]);
				}
			} else {
				text += itemdebug(x);
			}
		}
		console.log(time + '.' + ms, text.slice(0, -1));
	}
}

function pduToString(pdu) {
    var PDUstr = '';
	for (var i = 0; i < pdu.length; i++) {
		PDUstr += ('0' + pdu[i].toString(16)).slice(-2) + ' ';
	}
    return PDUstr;
}

/*
   Events:
   - found: a PowerMax device has been found; param: found ('no', 'active', 'inactive')
   - zone: a zone sensor has changed state; param: id, field, newVal (id = zone nr,
		field = ['tripAlarm', 'tamperAlarm', 'trip', 'tamper', 'battery', 'bypass'])
   - x10: an x10 device has changed state; param: id, field, newVal (id = x10 nr, field = ['on'])
   - system: the panel system state has changed; param: id, field, newVal (id = 0,
		field = ['status', 'ready', 'memory', 'trouble', 'alarm', 'event'])
			status: { armed (boolean), nr (int), txt (string) }
			event:  { ... }
			others return boolean
   - alarm: the alarm state has changed; param: id, field, newVal ??
   - zoneBattery: a zone battery event has occurred; param: zone, state
   - zoneTripAlarm: a zone battery event has occurred; param: zone, state
	 - eventLog: the event log received so far (field done indicates completenes)
	 - download: download state ('start', 'recieved:<page>,<index>', 'process:<setting>', 'failed', 'done')
*/

// Main constructor
function PowerMax(locale, settings, debug, stateless) {
	// settings
	//  ip: <string> ip address
	//  port: <number> port number
	//	syncTime: <boolean> synchronize time on panel automatically or not

	var self = this;
	this.locale = locale;
	this.ip_port = settings.ip + ':' + settings.port;
	this.forceModel = settings.forceModel || 'auto';
	this.devSettings = settings;
	this.debug = debug || function() { localDebug('[' + self.ip_port + ']', arguments); };
	this.stateless = (stateless !== undefined ? stateless : false)
	this.client;
	this.found = 'no' //TODO (id == null ? 'no' : 'inactive');
	this.intervalTimer;
	this.reconnectTimer;
	// Event handling
	this.events = new event.EventEmitter();
	this.eventLog = {};
	// Incoming message handling
	this.incomingPdu =[];
	this.incomingPduLen = 0; // expected length
	this.varLenMsg = false;
	this.lastPdu = [];
	this.expectedResponse = [];
	this.waitingForResponse = 0;
	this.rightResponse = 0;
	this.crcErrorCount = 0;
	// Outgoing message handling
	this.outgoingQueue = [];
	this.sendTimer = null;
	this.sendMsgRetries = 0;
	this.actionBusy = false;
	// Panel configuration
	this.panelTypeNr = 0;
	this.powerMaster = false;
	this.starting = false;
	this.downloadRetry = 0;
	this.powerlinkRetry = 0;
	this.powerlinkMode = false;
	// Panel settings
	this.settings = new Settings(this);
	this.readAllSettings = false;
	this.downloadState;
	// State of each zone
	this.zone = {};
	this.motionTimeout = [];

	this.events.setMaxListeners(0); // infinity
	this.eventLog = {};
	/*
	this.events.on('zone', function(id, field, value) {
		Homey.log('Zone status changed for zone ' + id + '; ' + field + ' = ' + value);
	});
	this.events.on('system', function(id, field, value) {
		Homey.log('System status changed for ' + field + ' = ' + value);
	});
	*/
	this.events.on('download', function(state) {
		self.downloadState = state; // can be 'start', 'failed' or 'done'
	});
	this.events.on('found', function(state) {
		if (state.found && self.intervalTimer === undefined) {
			// Set up regular check for every 20 seconds
			self.intervalTimer = setInterval(function() {
				var now = new Date();
				// Check Powerlink keep-alive
				if (self.powerlinkMode && !self.starting) {
					var delta = now - (self.waitingForResponse || 0);
					self.debug('Checking last alive message (delta =', delta + ')');
					if (delta > 40000) {
						// Let Powermax know we are alive (and reset Powerlink communication error)
						self.debug('Clear Powerlink communication error');
						self.sendMessage("MSG_RESTORE");
						self.powerlinkRetry++;
						if (self.powerlinkRetry == PL_RETRIES) {
							self.powerlinkMode = false;
							self.powerlinkRetry = 0;
						}
					}
				}
				// Check message sending timeout
				var timeout = (now - self.waitingForResponse > TIMEOUT);
				var notRight = (now - self.rightResponse > MAX_RESPONSE_TIME);
				if (self.expectedResponse != '' && (timeout || notRight)) {
					// resend last message
					self.debug('*** Re-sending PDU (no or incorrect response) ***');
					if (self.sendMsgRetries == MSG_RETRIES) {
						self.handleCommException('no response');
					} else {
						self.sendMsgRetries++;
						self.expectedResponse = self.expectedResponse.slice(1);
						self.sendMessage(-1);
					}
				}
			}, 20000);
		}
	});

	this.openConnection(settings.ip, settings.port);
}

// Open the connection to this PowerMax panel
PowerMax.prototype.openConnection = function(ip, port) {
	var self = this;

	// Set up network communication
	this.client = new net.Socket();
	this.client.setTimeout(60000); // expect traffic once a minute
	// Register main response handler
	this.client.on('data', function(data) {
		//clearTimeout(waitTimer);
		self.processData(data);
	});
	// Error handler
	this.client.on('error', function(err) {
		self.debug(err);
		if (self.found != 'no') {
			//clearTimeout(waitTimer);
			self.closeConnection();
		}
	});
	// Timeout handler
	this.client.on('timeout', function() {
		self.debug('Connecion timed out.');
		self.events.emit('found', { found: self.found, err: 'Timed out' });
		self.closeConnection();
	});
	// Handle closed connections, try to re-open it
	this.client.on('close', function() {
		self.debug('Connecion closed (found =', self.found + ')');
		self.events.emit('found', { found: false, err: 'Connection closed' });
		if (self.found != 'no' && self.reconnectTimer === undefined) {
			// Connection dropped, try to re-connect every minute
			self.reconnectTimer = setInterval(function() {
				var ip = self.devSettings.ip;
				var port = self.devSettings.port;
				self.debug('Re-connecting to', ip + ':' + port);
				self.openConnection(ip, port);
			}, 60000);
		}
	});
	this.client.connect(port, ip, function() {
		self.debug('Connected to', self.ip_port);
		// Kill the re-try timer
		clearInterval(self.reconnectTimer);
		self.reconnectTimer = undefined;
		// Start communication
		self.startDownload();
	});
}

// Close the connection to this PowerMax panel
PowerMax.prototype.closeConnection = function() {
	this.client.destroy();
	this.found = (this.found == 'no' ? 'no' : 'inactive');

	// Reset all variables
	this.incomingPdu =[];
	this.incomingPduLen = 0; // expected length
	this.varLenMsg = false;
	this.lastPdu = [];
	this.expectedResponse = [];
	this.waitingForResponse = 0;
	this.rightResponse = 0;
	this.crcErrorCount = 0;
	this.outgoingQueue = [];
	this.sendTimer = null;
	this.sendMsgRetries = 0;
	this.actionBusy = false;
	this.starting = false;
	this.downloadRetry = 0;
	this.powerlinkRetry = 0;
	this.powerlinkMode = false;
	this.readAllSettings = false;

	clearInterval(this.intervalTimer);
	this.intervalTimer = undefined;
}

PowerMax.prototype.handleCommException = function(reason) {
	this.debug('>>> Communication error:', reason, '- restarting <<<')
	var ip = this.devSettings.ip;
	var port = this.devSettings.port;
	this.closeConnection(); // start from scratch
	var self = this;
	// Wait a second before we open the connection again. Other async processes need to finish.
	setTimeout(function() {
		self.debug('Re-connecting to', ip + ':' + port);
		self.openConnection(ip, port);
	}, 1000);
}

// Determine whether we are in normal operating mode or not
PowerMax.prototype.isNormalMode = function() {
	var lastType = this.lastPdu[1];
	var normalMode = (lastType >= 0x80 || ((lastType < 0x10) && this.lastPdu[this.lastPdu.length - 2]) == 0x43);
	return normalMode;
}

// sendPdu: Send the pdu to the PowerMax via serial
PowerMax.prototype.sendPdu = function(pdu) {
	var sendPdu = pm.calcCRC(pdu);
	var PDUstr = pduToString(sendPdu);
	this.debug('PDU sent to panel:', PDUstr);
	this.client.write(new Buffer(sendPdu));
	return sendPdu;
}

// sendAck: Send full or partial acknowledge to Powermax (depending on operating mode)
PowerMax.prototype.sendAck = function(ackType) {
	if (this.isNormalMode() == true) {
		this.sendPdu([0x0D, ackType, 0x43, 0x00, 0x0A]);
	} else {
		this.sendPdu([0x0D, ackType, 0x00, 0x0A]);
	}
}

// startDownload
PowerMax.prototype.startDownload = function() {
	if (this.starting == false) {
		this.events.emit('download', 'enroll');
		this.starting = true;
		this.events.emit('busy', true)
		this.sendMessage("MSG_DOWNLOAD", { code: pm.secret }); // If we get a NACK, then the download code is not valid (not enrolled)
	} else {
		this.downloadRetry++;
		if (this.downloadRetry > MAX_IGNORE_DOWNLOAD) {
			this.downloadRetry = 0;
			this.sendMessage("MSG_DOWNLOAD", { code: pm.secret }); // If we get a NACK, then the download code is not valid (not enrolled)
		} else {
			this.debug('Download not started as one is in progress.')
		}
	}
}


// writeMessage
// item: address
//   or: DL_xxx
PowerMax.prototype.writeMessage = function(item, val) {
	var len = val.length;
	var addr;
	if (typeof item == 'string') {
		addr = pm.download[item].slice(0, 1);
	} else {
		addr = [item % 0x100, math.floor(item / 0x100)];
	}
	while (len > 0) {
		var s = val.slice(0, 0xAF);
		var l = (len > 0xB0) ? 0xB0 : len;
		this.debug('addr = ' + addr + ', len = ' + l);
		this.sendMessage("MSG_WRITE", { addr: addr, len: l, val: s });
		var page = string.byte(addr, 2)
		var index = string.byte(addr)
		//pmWriteSettings(page, index, s) // also update internal table
		len -= 0xB0;
		val = val.slice(0xB0);
		var a = 0x100 * page + index + 0xB0;
		addr = [a % 0x100, math.floor(a / 0x100)];
    }
}

// sendDelayed
PowerMax.prototype.sendDelayed = function(msgPdu) {
	this.debug('*** Trigger: delayed sending of', msgPdu.msg, ' ***');
	this.sendTimer = null;
	this.sendMessage('PDU', msgPdu);
}

// sendMessage: Send (known) messages to the PowerMax
// Returns success: true: sent or queued; false: nothing sent
PowerMax.prototype.sendMessage = function(msg, modifiers, immediate) {
	var outPdu = [];
	var response;
	var interval = new Date() - this.waitingForResponse;
	var timeout = (interval > TIMEOUT);

	if (msg == -1) { // re-send last message
		msg = 'RESENDING';
		outPdu = this.lastSentPdu;
		response = this.expectedResponse;
		timeout = true;
	} else if (msg == 'PDU') {
		msg = modifiers.msg;
		outPdu = modifiers.pdu;
		response = modifiers.resp;
	} else if (msg != null) {
		var msgItem = pm.send[msg];
		outPdu = [0x0D];

		for (var i = 0; i < msgItem.msg.length; i++) {
			var elem = msgItem.msg[i];
			if (typeof elem != 'string') {
				outPdu.push(elem);
			} else {
				// handle modifier
				var p = elem.indexOf(':');
				var len = 1;
				if (p > 0) {
					len = Number(elem.slice(p + 1));
					elem = elem.slice(0, p);
				}
				var val = modifiers[elem];
				if (typeof val == 'number') {
					// make sure we have an array of correct length
					var tmp = val;
					val = [];
					for (var j = 0; j < len; j++) {
						val[j] = tmp & 0xff;
						tmp >>= 8;
					}
				} else {
					if (val == null || val.length != len) {
						this.debug('Provide array of length', len, 'for', elem);
						return false;
					}
				}
				outPdu = outPdu.concat(val);
			}
		}
		outPdu.push(0x00, 0x0A);
		response = msgItem.resp != null ? [ msgItem.resp ] : null;

		if (outPdu[1] == 0x3E) {
			var cnt = outPdu[4] + 0x100 * outPdu[5];
			//TODO: optimize
			for (var i = 0; i < Math.floor(cnt / 0xB0); i++) {
				response.push(msgItem.resp);
			}
		}
	}

	if (immediate == true || this.sendTimer == null && (timeout == true || this.expectedResponse.length == 0)) { // we are ready to send
		if (msg == null) { // get message from queue
			var tab = this.outgoingQueue.shift();
			if (tab == null) {
				// nothing to send
				return false
			}
			msg = tab.msg;
			outPdu = tab.pdu;
			response = tab.resp;
		}
		// check if the last read is at least 500 ms ago
		if (!immediate && interval < 500) {
			// there should be at least 500 ms between last receive and a new send
			this.debug('*** Send message,', msg, 'delayed ***')
			var self = this;
			this.sendTimer = setTimeout(function() { self.sendDelayed({ msg: msg, pdu: outPdu, resp: response }); }, 500 - interval);
			return true;
		}
		// always expect an ACK (ACK send messages don't pass through here)
		this.expectedResponse = [0x02];
		if (response != null) {
			this.rightResponse =  new Date();
			this.expectedResponse = [0x02].concat(response);
		}
		this.lastPdu = this.sendPdu(outPdu);
		this.lastSentPdu = this.lastPdu;
		// TODO: check how to return false if sending failed
		this.waitingForResponse = new Date();
	} else if (msg != null) { // queue message
		this.outgoingQueue.push({ msg: msg, pdu: outPdu, resp: response });
	}
	return true;
}

// Process incoming PDUs
PowerMax.prototype.processData = function(data) {
	// Don't assume we get a full PDU right away
	for (var p = 0; p < data.length; p++) {
		var pdu = data[p];
		var pduLen = this.incomingPdu.length;
		var success, ignore;

		if (pduLen == 4 && this.varLenMsg == true) {
			// Determine length of variable size message
			var msgType = '0x' + ('0'+ this.incomingPdu[1].toString(16).toUpperCase()).slice(-2);
			this.incomingPduLen += pdu + 7
			this.debug('Message', msgType + '; incomingPduLen =', this.incomingPduLen);
		}

	   if (pduLen == 0) {
			if (pdu == 0x0D) { // preamble
				var response = '';
				if (this.expectedResponse.length != 0) {
					response = pduToString(this.expectedResponse);
					if (response != '') {
						response = "; Expecting " + response;
					}
				}
				this.debug('Start of new PDU detected', response);
				this.incomingPdu[0] = pdu;
			}
		} else if (pduLen == 1) {
			var msgType = '0x' + ('0'+ pdu.toString(16).toUpperCase()).slice(-2);
			var msgType_t = pm.receive[msgType];
			this.incomingPduLen = msgType_t == null ? 0 : msgType_t.len || 0; // fix #2
			this.varLenMsg = (msgType > 0x10) && (msgType_t != null) && (msgType_t.len == null);
			this.debug('Message', msgType + '; incomingPduLen =', this.incomingPduLen);
			this.incomingPdu.push(pdu);
		} else if ((this.incomingPduLen == 0 && pdu == 0x0A) || (pduLen + 1 == this.incomingPduLen)) { // postamble
			this.incomingPdu.push(pdu);
			var crc;
			var msgType = '0x' + ('0'+ this.incomingPdu[1].toString(16).toUpperCase()).slice(-2);
			if (pdu != 0x0A && this.incomingPdu[pduLen - 1] == 0x43) {
				this.incomingPduLen++; // for 0x43
			} else if (crc = pm.checkCRC(this.incomingPdu) == true) {
				if (this.found != 'active') {
					this.found = 'active';
					this.events.emit('found', { found: true });
				}
				this.lastPdu = this.incomingPdu;
				var PDUstr = pduToString(this.incomingPdu);
				var msgType_t = pm.receive[msgType];
				this.debug('PDU received', PDUstr);
				this.waitingForResponse = new Date();

				if (msgType_t == null) {
					this.debug('Unhandled message', msgType);
					this.sendAck(0x02);
				} else {
					// Send an ACK if needed
					if (msgType_t.ack) {
					   this.sendAck(0x02);
					}
					// Handle the message
					var success, ignore;
					var call = handler[msgType_t.handler];
					if (call == null) {
						this.debug('Unhandled message', msgType + '; handler:', msgType_t.handler);
					} else {
						success, ignore = call(this);
					}
					// Check response
					if (this.expectedResponse.length != 0) {
						// We've sent something and are waiting for a response - this is it
						var firstExpected = this.expectedResponse[0];
						var firstExpectedResponse = '0x' + ('0' + firstExpected.toString(16).toUpperCase()).slice(-2);
						this.expectedResponse = this.expectedResponse.slice(1);
						if (firstExpectedResponse != msgType) {
							if (ignore == true) { // ignore unexpected messages
								this.debug('Ignoring response...');
								this.expectedResponse.unshift(firstExpected);
							} else if (this.sendMsgRetries == 0) {
								this.debug('*** Waiting for next PDU (expected', firstExpectedResponse, 'got', msgType + ') ***');
								this.sendMsgRetries = 1; // don't respond immediately - first wait for the next response
								this.expectedResponse.unshift(firstExpected);
							} else {
								this.debug('*** Re-sending PDU (expected', firstExpectedResponse, 'got', msgType + ') ***');
								if (this.sendMsgRetries == MSG_RETRIES) {
									this.handleCommException('wrong response');
								} else {
									this.sendMsgRetries++;
									this.sendMessage(-1);
								}
							}
						} else {
							this.sendMsgRetries = 0;
							this.rightResponse = new Date();
						}
					}
				}
				this.incomingPdu = [];
				if (this.expectedResponse.length == 0) {
					this.sendMessage(null);
				}
			} else { // CRC check failed
				if (this.incomingPduLen > 0) {
					var PDUstr = pduToString(this.incomingPdu);
					this.debug('PDU with CRC error', PDUstr);
					this.waitingForResponse = new Date();
					this.incomingPdu = [];
					if (msgType != 0xF1) { // ignore CRC errors on F1 message
						this.crcErrorCount++;
					}
					if (this.crcErrorCount > MAX_CRC_ERROR) {
						//this.handleCommException("CRC errors")
					}
				} else {
					this.debug('Length is now', pduLen, '(apparently PDU not complete)');
					var PDUstr = pduToString(this.incomingPdu);
					this.debug('Partial PDU', PDUstr);
				}
			}
		} else if (pduLen <= 0xC0) {
			this.incomingPdu.push(pdu);
		} else {
			var PDUstr = pduToString(this.incomingPdu);
			this.debug('Truncating PDU', PDUstr);
			this.incomingPdu = []; // messages should never be longer than 0xC0
		}
	} // end for
};

// Request a status update from the pane;
PowerMax.prototype.getZoneStatus = function(zone) {
	// TODO: create specific message for a zone
	this.sendMessage("MSG_STATUS");
}

// Bypass a list of zones
// which: sensors to send the command for (array of numbers)
PowerMax.prototype.setBypass = function(user, which, on) {
	if (which !== undefined && which.length > 0 && this.settings.config && this.settings.config.userCode) {
		let addr = 0;
		let pin = this.settings.config.userCode[user - 1];
		for (let i = 0; i < which.length; i++) {
			addr += Math.pow(2, which[i] - 1);
		}
		this.debug('setBypass', on, addr)
		if (on) {
			this.sendMessage("MSG_BYPASSEN", { pin: pin, bypass: addr });
		} else {
			this.sendMessage("MSG_BYPASSDI", { pin: pin, bypass: addr });
		}
		this.sendMessage("MSG_BYPASSTA"); // request status to check success and update variable
	}
}

// Check if another action is busy
PowerMax.prototype.panelBusy = function() {
	return this.actionBusy || this.starting;
}

// Synchronize time from Homey to the PowerMax
PowerMax.prototype.syncTime = function() {
	if (!this.panelBusy()) {
		this.actionBusy = true;
		this.events.emit('busy', true)
		this.sendMessage("MSG_DOWNLOAD", { code: pm.secret }); // Open download mode
		if (this.devSettings.syncTime) {
			var t = new Date();
			var year = t.getFullYear() - 2000;
			var timePdu = [t.getSeconds(), t.getMinutes(), t.getHours(), t.getDate(), t.getMonth() + 1, year];
			t.setMilliseconds(0);
			this.syncTimeCheck = t;
			this.sendMessage("MSG_SETTIME", { time: timePdu });
		}
		this.sendMessage("MSG_EXIT");  // Exit download mode
		this.actionBusy = false;
		this.events.emit('busy', false)
	} else {
		// busy, try again later
		var self = this;
		setTimeout(function() { self.syncTime() }, 1000);
	}
}

// Control X10 devices
// which: devices to send the command for (array of numbers; 0 = PGM)
PowerMax.prototype.sendX10Command = function(which, what) {
	const x10cmds = { //TODO: move to tables
		'off': 0x0,
		'on': 0x01,
		'dim': 0x0a,
		'brighten': 0x0b
	}
	if (x10cmds[what] != null) {
		var addr = 0;
		for (var i = 0; i < which.length; i++) {
			addr += Math.pow(2, which[i]);
		}
		this.sendMessage("MSG_X10PGM", { cmd: x10cmds[what], device: addr });
	}
}

// Request the event log
PowerMax.prototype.getEventLog = function(force) {
	let result = false;
	if (!force && this.eventLog.done) {
		this.events.emit('eventLog');
		result = true;
	} else if (!this.panelBusy()) {
		if (this.settings && this.settings.config && this.settings.config.userCode) {
			let pin = this.settings.config.userCode[0]; // always use user 1
			if (pin !== undefined) {
				this.sendMessage("MSG_EVENTLOG", { pin: pin });
				result = true;
			}
		}
	}
	return result;
}

// powerlinkEnrolled
PowerMax.prototype.powerlinkEnrolled = function() {
	this.sendMessage("MSG_DL", { item: pm.download.MSG_DL_PANELFW }); // Request the panel FW
	this.sendMessage("MSG_DL", { item: pm.download.MSG_DL_SERIAL }); // Request serial & type (not always sent by default)
	this.sendMessage("MSG_DL", { item: pm.download.MSG_DL_ZONESTR }); // Read the names of the zones
	if (this.powerMaster) {
		this.sendMessage("MSG_DL", { item: pm.download.MSG_DL_MR_SIRKEYZON });
	}
	if (this.devSettings.syncTime) {
		var t = new Date();
		var year = t.getFullYear() - 2000;
		var timePdu = [t.getSeconds(), t.getMinutes(), t.getHours(), t.getDate(), t.getMonth() + 1, year];
		t.setMilliseconds(0);
		this.syncTimeCheck = t;
		this.sendMessage("MSG_SETTIME", { time: timePdu });
	}
	this.sendMessage("MSG_START"); // Start sending all relevant settings please
	this.sendMessage("MSG_EXIT");  // Exit download mode
}

module.exports = PowerMax;
