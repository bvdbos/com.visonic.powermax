"use strict";

const pm = require('./tables.js');

// bytes2Dword: convert 4 bytes into an double-word integer
function bytes2Dword(arr) {
	return arr[0] + 0x100 * arr[1] + 0x10000 * arr[2] + 0x1000000 * arr[3];
}

// Update a variable only if the value will change
function updateStatus(state, what, field, newVal) {
	if (state.stateless) {
		state.events.emit(what, field, newVal)
		state.debug(what + ':' + field, 'is now', newVal);
	} else {
		if (state.zone[what] == null) {
			state.zone[what] = {};
		}
		var curVal = state.zone[what][field];
		var changed = curVal != null && typeof newVal == 'object' ? newVal.nr != curVal.nr : newVal != curVal;
		if (changed) {
			state.zone[what][field] = newVal;
			state.events.emit(what, field, newVal);
			if (typeof newVal == 'object') {
				curVal = JSON.stringify(curVal);
				newVal = JSON.stringify(newVal);
			}
			state.debug(what + ':' + field + ' was ' + curVal + ' now ' + newVal);
			return true;
		} else {
			return false;
		}
	}
}

var self = module.exports = {
	// pmHandleAck (0x02)
	handleAck: function(state) {
		if (state.lastSentPdu != null) {
			var lastSentPduType = state.lastSentPdu[1];

			if (lastSentPduType == 0x0F && state.starting && state.readAllSettings) {
				state.powerlinkMode = true; // we have all info
				state.settings.process('all');
				state.events.emit('download', 'done');
			}
			return true;
		}
		return false;
	},

	// pmHandleTimeout (0x06)
	handleTimeout: function(state) {
	   state.debug("Powermax sends timeout");
	   state.expectedResponse = [0x06];
	   state.sendMessage("MSG_EXIT");
	   return true
	},

	// pmHandleDenied (0x08)
	handleDenied: function(state) {
		var lastSentPduType = state.lastSentPdu[1];
   	state.debug("Handling DENIED message (" + lastSentPduType + ")");

   	if ((lastSentPduType & 0xA0) == 0xA0) { // A0, A1, AA
		  //pmUserMessage("WRONG_PIN")
		  if (lastSentPduType == 0xA0) {
				state.eventLog = { done: true, denied: true, items: [], time: new Date() };
				state.events.emit('eventLog');
  			state.events.emit('busy', false);
		  }
   	} else if (lastSentPduType == 0x24) {
		  state.powerlinkMode = false;
		  state.starting = false;
		  state.events.emit('download', 'failed');
		  //pmUserMessage("NOT_ENROLLED");
		  //state.settings.process();
   	}
   	state.expectedResponse = [0x08];
		state.events.emit('busy', false)
   	return true
	},

	// pmHandleStop (0x0B)
	handleStop: function(state) {
	   // We're not expecting any more responses
	   state.readAllSettings = true;
	   state.expectedResponse = [];
	   return true
	},

	// pmHandleDownloadRetry (0x25)
	handleDownloadRetry: function(state) {
	   // Panel is not ready to enter download mode
	   var waitTime = state.incomingPdu[4] * 1000;
	   state.expectedResponse[0] = 0x25; // act like this was expected
	   state.sendTimer = setTimeout(function() { state.sendDelayed({ msg: 'RETRY', pdu: state.lastSentPdu, resp: 0x3C }); }, waitTime);
	},

	// pmHandleSettings (0x33)
	handleSettings: function(state) {
		if (state.lastSentPdu != null) {
			var index = state.incomingPdu[2];
			var page = state.incomingPdu[3];
			var lastSentPduType = state.lastSentPdu[1];
			state.debug('Received Powermax setting page ' + page + ' index ' + index);
			if (lastSentPduType == 0x0A) {
				state.expectedResponse.push(0x33); // we're not done; keep them coming
			}
			state.settings.write(page, index, state.incomingPdu.slice(4, 12));
			state.events.emit('download', 'received:' + page + ',' + index);
			return true;
		}
		return false;
	},

	// pmHandleInfo (0x3C)
	handleInfo: function(state) {
		var panelTypeNr = state.incomingPdu[7] + 1;
		var powerMaster = (panelTypeNr >= 8);
		if (state.forceModel !== 'auto') {
			powerMaster = state.forceModel === 'powermaster'
		}
		state.panelTypeNr = panelTypeNr;
		state.powerMaster = powerMaster;
		var type = pm.panelType[panelTypeNr] || "UNKNOWN";
		state.settings.config.panelType = type;
		state.debug("Model: " + type + "; Nr: " + panelTypeNr + "; Master: " + (powerMaster ? "Yes" : "No"));
		//if (luup.variable_get(PANEL_SID, "PowerlinkMode", pmPanelDev) != "Program") {
		if (state.starting) {
			state.events.emit('download', 'start');
			state.powerlinkEnrolled();
		}
		return true
	},

	// pmHandleSettingsItem (0x3F)
	handleSettingsItem: function(state) {
		var idx = state.incomingPdu[2];
		var page = state.incomingPdu[3];
		var len = state.incomingPdu[4];
		state.debug('Received Powermax setting page ' + page + ' index ' + idx);
		state.settings.write(page, idx, state.incomingPdu.slice(5, 5 + len));
		for (var i in pm.download) {
			var item = pm.download[i];
			if (item[0] == idx && item[1] == page && item[2] == len && item[3] == 0) {
				state.settings.process(i);
				state.events.emit('download', 'process:' + i);
			}
		}
	},

	// pmHandleEventlog (0xA0)
	handleEventlog: function(state) {
		var eventNum = state.incomingPdu[3];
		if (eventNum == 0x01) {
			state.eventLog = { done: false, denied: false, items: [], time: new Date() };
			state.events.emit('busy', true);
			state.expectedResponse.push(0xA0);
		} else if (state.eventLog.items) {
			var secNum = state.incomingPdu[4];
			var minNum = state.incomingPdu[5];
			var horNum = state.incomingPdu[6];
			var dayNum = state.incomingPdu[7];
			var monNum = state.incomingPdu[8];
			var yerNum = 2000 + state.incomingPdu[9];
			var eventZone = state.incomingPdu[10];
			var logEvent = state.incomingPdu[11];
			var zoneStr = pm.logUser[state.locale][eventZone] || "UNKNOWN";
			//TODO:if (isPanelEvent == true) {
			//   pmEventLog = pmEventLog + "  * "
			//else
			//   pmEventLog = pmEventLog + "    "
			//end
			var eventStr = pm.logEvent[state.locale][logEvent] || "UNKNOWN";
			var idx = eventNum - 1;
			var event = {};
			var time = ('0' + horNum).slice(-2) + ':' + ('0' + minNum).slice(-2);
			if (pm.panelConfig.CFG_PARTITIONS[state.panelTypeNr] > 1) {
				var part = 0;
				for (var i = 1; i <= 3; i++) {
					part = (secNum % (2 * i) >= i) ? i : part;
				}
				event = { partition: (part == 0 ? "Panel" : part), time: time };
			} else {
				time += ':' + ('0' + secNum).slice(-2);
				event = { partition: (eventZone == 0 ? "Panel" : "1"), time: time };
			}
			event.date = ('0' + dayNum).slice(-2) + '/' + ('0' + monNum).slice(-2) + '/' + yerNum;
			event.zone = zoneStr;
			event.event = eventStr;
			state.debug(event, eventNum, state.incomingPdu[2]);
			state.eventLog.items.push(event);
			state.eventLog.done = eventNum == state.incomingPdu[2];
			state.events.emit('eventLog')
			if (state.eventLog.done) {
				state.events.emit('busy', false);
			}
		}
		return true;
	},

	// pmHandleStatus (0xA5)
	handleStatus: function(state) {
		var displaySensorBypass = function(sensor) {
			var armed
			/*
			if (state.sensorShowBypass == true) {
				armed = (sensor['bypass'] == true) ? 0 : 1;
			} else {
				var zoneType = sensor['ztype'] - 1;
				var mode = state.sysStatus & 0x0F;
				armed = ((zoneType > 0) && (sensor['bypass'] != true)
					&& ((zoneType & 0x14) == 0) || (mode == 0x5) || ((mode == 0x4) && (zoneType % 6 != 0)))) ? "1" : "0";
			}
			updateIfNeeded(SECURITY_SID, "Armed", armed, sensor['id']);
			*/
		}

		var msgTot = state.incomingPdu[2];
		var eventType = state.incomingPdu[3];
		//if (msgTot > 0 && eventType != msgTot) {
		//	  state.expectedResponse.push(0xA5);// we're not done; keep them coming
		//}
		if (eventType == 0x01) { // Zone alarm status
			state.debug("Received zone alarm status message")
			var alarmStatus = bytes2Dword(state.incomingPdu.slice(4, 8));
			var tamperStatus = bytes2Dword(state.incomingPdu.slice(8, 12));
			for (var i = 1; i <= 30; i++) {
				var alarm = (alarmStatus & Math.pow(2 , (i - 1))) > 0;
				var tamper = (tamperStatus & Math.pow(2, (i - 1))) > 0;
				if (state.settings.zones[i] != null) {
					if (updateStatus(state, 'zone.' + i, 'tripAlarm', alarm)) {
						state.debug('Updating trip alarm status for zone device ' + i + ' (' + alarm + ')');
						state.events.emit('zoneTripAlarm', { zone: i, state: alarm });
					}
					if (updateStatus(state, 'zone.' + i, 'tamperAlarm', tamper)) {
						state.debug('Updating tamper alarm status for zone device ' + i + ' (' + tamper + ')');
						state.events.emit('zoneTamperAlarm', { zone: i, state: tamper });
					}
				} else {
					if (alarm) {
						state.debug('Sensor zone ' + i + ' in trip alarm, but no device found!');
					} else if (tamper) {
						state.debug('Sensor zone ' + i + ' tamper alarm, but no device found!');
					}
				}
			}
		} else if (eventType == 0x02) { // Zone open status
			state.debug("Received zone open status message")
			var zoneStatus = bytes2Dword(state.incomingPdu.slice(4, 8));
			var batteryStatus = bytes2Dword(state.incomingPdu.slice(8, 12));
			for (var i = 1; i <= 30; i++) {
				var trip = (zoneStatus & Math.pow(2 , (i - 1))) > 0;
				var battery = (batteryStatus & Math.pow(2, (i - 1))) > 0;
				if (state.settings.zones[i] != null) {
					if (updateStatus(state, 'zone.' + i, 'trip', trip)) {
						state.debug('Updating tripped status for zone device ' + i + ' (' + trip + ')');
						state.events.emit('zoneTrip', { zone: i, state: trip });
					}
					if (updateStatus(state, 'zone.' + i, 'battery', battery)) {
						state.debug('Updating battery status for zone device ' + i + ' (' + battery + ')');
						state.events.emit('zoneBattery', { zone: i, state: battery });
					};
				} else {
					if (trip) {
						state.debug('Sensor zone ' + i + ' tripped, but no device found!');
					} else if (battery) {
						state.debug('Sensor zone ' + i + ' low battery, but no device found!');
					}
				}
			}
		} else if (eventType == 0x03) { // Zone tamper message
			var inactiveStatus = bytes2Dword(state.incomingPdu.slice(4, 8));
			var tamperStatus = bytes2Dword(state.incomingPdu.slice(8, 12));
			for (var i = 1; i <= 30; i++) {
				var tamper = (tamperStatus & Math.pow(2, (i - 1))) > 0 ? true : false;
				if (state.settings.zones[i] != null) {
					if (updateStatus(state, 'zone.' + i, 'tamper', tamper)) {
						state.debug('Updating tamper status for zone device ' + i + ' (' + tamper + ')');
						state.events.emit('zoneTamper', { zone: i, state: tamper });
					}
				} else {
					if (tamper) {
						state.debug('Sensor zone ' + i + ' tampered, but no device found!');
					}
				}
			}
		} else if (eventType == 0x04) { // Zone event message
			var sysStatus = state.incomingPdu[4];
			state.sysStatus = sysStatus; // TODO: do we need this?
			var sysFlags  = state.incomingPdu[5];
			var eventZone = state.incomingPdu[6];
			var zoneEType = state.incomingPdu[7];

			if (zoneEType != 0x00) {
				state.debug("Event " + (pm.eventType[state.locale][zoneEType] || "UNKNOWN") + " in Zone " + eventZone);
				var zone = state.settings.zones[eventZone];
				if (zone == null) {
					state.debug("Unable to locate zone "  + eventZone);
				} else {
					if (zoneEType == 0x03) { // Open event door/window sensor
						updateStatus(state, 'zone.' + eventZone, 'trip', true); // prevent updating twice; status msg comes before event msg
					} else if (zoneEType == 0x04) { // Close event door/window sensor
						updateStatus(state, 'zone.' + eventZone, 'trip', false);
					} else if (zoneEType == 0x05) { // Motion event
						updateStatus(state, 'zone.' + eventZone, 'trip', true);
						if (state.motionTimeout[eventZone] != null) {
							clearTimeout(state.motionTimeout[eventZone]);
						}
						state.motionTimeout[eventZone] = setTimeout(function() {
							updateStatus(state, 'zone.' + eventZone, 'trip', false);
						}, 1000 * state.devSettings.motionTime);
					}
				}
			}

			// Update status of PGM & X10 devices
			var s;
			var x10Stat1  = state.incomingPdu[10];
			var x10Stat2  = state.incomingPdu[11];
			var x10Status = x10Stat1 + (x10Stat2 * 0x100);
			for (var i = 0; i <= 15; i++) {
				s = (i == 0 ? 'x10.PGM' : 'x10.' + i);
				var status = (x10Status & Math.pow(2, i)) > 0;
				if (updateStatus(state, s, 'on', status) == true) {
					state.debug('Updating status of X10 device ' + s + ' (status = ' + status + ')');
				}
			}

			// System status flags
			var sysFlagsStr = " ";
			var ready = (sysFlags & 1) == 1;
			var memory = (sysFlags & 2) == 2;
			var trouble = (sysFlags & 4) == 4;
			var alarm = (sysFlags & 128) == 128;
			updateStatus(state, 'system', 'ready', ready);
			updateStatus(state, 'system', 'memory', memory);
			updateStatus(state, 'system', 'trouble', trouble);
			updateStatus(state, 'system', 'alarm', alarm);
			if (!ready) {
				sysFlagsStr += ",NRDY";
			}
			if (memory) {
				sysFlagsStr += ",MEM";
			}
			if (trouble) {
				sysFlagsStr += ",TRBL";
			}
			if (alarm) {
				sysFlagsStr += ",ALRM";
			}
			var armMode = pm.isArmed[sysStatus] != null;
			var statusText = pm.sysStatus[state.locale] == null ? pm.sysStatus.en[sysStatus] : pm.sysStatus[state.locale][sysStatus];
			updateStatus(state, 'system', 'status',
				{ armed: armMode, nr: sysStatus, detail: pm.detailedArmMode[sysStatus], txt: statusText }
			);
			//var armMode = (armModeNum == 1) ? "Armed" : "Disarmed";
			var s = '';
			for (var i = 0; i <= 7; i++) {
				if (sysFlags & Math.pow(2, i) != 0) {
					if (i == 5) {
						if (eventZone == 0xFF) {
							s += (pm.eventType[state.locale][zoneEType] || "UNKNOWN") + " from Panel, ";
					   } else {
							s += pm.eventType[state.locale][zoneEType] + " in Zone " + eventZone + ", ";
					   }
					} else {
						s += (pm.sysStatusFlags[state.locale][i] || "UNKNOWN") + ", ";
					}
				}
			}
			s = (s == "") ? "Not ready" : s.slice(-2);
			state.debug("System state is " + (pm.sysStatus[state.locale][sysStatus] || "UNKNOWN") + ' ' + sysFlagsStr);
			//updateIfNeeded(PARTITION_SID, "VendorStatus", (pmSysStatus_t[locale][pmSysStatus + 1]  or "UNKNOWN") + sysFlagsStr, pmPartitionDev_t[1])
			//updateIfNeeded(PARTITION_SID, "VendorStatusCode", string.format("%02X%02X", pmSysStatus, sysFlags), pmPartitionDev_t[1])
			//updateIfNeeded(PARTITION_SID, "VendorStatusData", s, pmPartitionDev_t[1])
			//updateIfNeeded(PARTITION_SID, "DetailedArmMode", (pmDetailedArmMode_t[pmSysStatus + 1] or "UNKNOWN"), pmPartitionDev_t[1])
			/*
			if (state.sensorShowBypass == false) {
				for (var i = 1; i <= 30; i++) {
					//var sensor = pmSensorDev_t[i]
					//if (sensor != null) {
					//   displaySensorBypass(sensor);
					//}
				 }
			}
			*/
		} else if (eventType == 0x06) {
			state.debug("Received zone bypass message")
			var zoneEnrolled = bytes2Dword(state.incomingPdu.slice(4, 8));
			var zoneBypass = bytes2Dword(state.incomingPdu.slice(8, 12));
			for (var i = 1; i <= 30; i++) {
				var enrolled = (zoneEnrolled & Math.pow(2, (i - 1))) > 0;
				var bypass = (zoneBypass & Math.pow(2, (i - 1))) > 0;
				updateStatus(state, 'zone.' + i, 'bypass', bypass);
				/*
				var sensor = pmSensorDev_t[i];
				if (sensor != null) {
					sensor['enrolled'] = enrolled;
					sensor['bypass'] = bypass;
					displaySensorBypass(sensor);
				} else if (enrolled == true) {
					state.debug("Found zone " + i + " to be enrolled while not registered.");
					pmSensorDev_t[i] = {};
					pmSensorDev_t[i].enrolled = enrolled;
					pmSensorDev_t[i].bypass = bypass;
				}
				*/
			}
		}
		return true;
	},

	// pmHandleZoneName (0xA3)
	handleZoneName: function(state) {
		var rowCnt = state.incomingPdu[3];
		for (var i = 1; i <= 8; i++) {
			var idx = (rowCnt - 1) * 8 + i;
			//var sensor = pmSensorDev_t[idx];
			//if (sensor != null) {
				var zoneName = state.incomingPdu[3 + i];
				//sensor.zname = pmZoneName_t[zoneName + 1]
				//state.debug("Adding zone name " + sensor.zname + " for zone " + idx);
			//}
	   }
	   return true;
	},

	// pmHandleZoneType (0xA6)
	handleZoneType: function(state) {
		var rowCnt = state.incomingPdu[3];
		for (var i = 1; i <= 8; i++) {
			var idx = (rowCnt - 1) * 8 + i;
			//var sensor = pmSensorDev_t[idx];
			//if (sensor != null) {
				var zoneInfo = state.incomingPdu[3 + i] - 0x1E;
				var zoneType = (zoneInfo & 0x0F) + 1;
				//sensor.ztype = zoneType
				//sensor.ztypeName = pmZoneType_t[locale][zoneType]
				//state.debug("Adding zone type " + sensor.ztypeName + " for zone " + idx);
			//}
		}
		return true;
	},

	// pmHandlePanel (0xA7)
	handlePanel: function(state) {
		var msgCnt = state.incomingPdu[2];
		for (var i = 1; i<= msgCnt; i++) {
			var eventZone = state.incomingPdu[2 + 2 * i];
			var logEvent  = state.incomingPdu[3 + 2 * i];
			var eventType = logEvent & 0x7F;
			var s = (pm.logEvent[state.locale][eventType] || 'UNKNOWN') + ' / ' + (pm.logUser[state.locale][eventZone] || 'UNKNOWN');
			state.debug("System message: " + s);
			var eventIdx = '0x' + ('0' + eventType.toString(16)).slice(-2);
			var alarmStatus = pm.panelAlarmType[eventIdx] || eventIdx;
			var troubleStatus = pm.panelTroubleType[eventIdx] || eventIdx;
			updateStatus(state, 'system', 'event', {
				nr: eventIdx,
				type: pm.logEvent[state.locale][eventType], // type of event
				userType: eventZone,
				userText: pm.logUser[state.locale][eventZone],
				alarmType: alarmStatus,
				alarmText: pm.panelAlarmText[state.locale][alarmStatus],
				troubleType: troubleStatus,
				toubleText: pm.panelTroubleText[state.locale][troubleStatus]
			});
			updateStatus(state, 'system', 'alarmType', {
				nr: alarmStatus,
				loc: pm.panelAlarmText[state.locale][alarmStatus],
				txt: (alarmStatus !== undefined ? pm.logEvent[state.locale][eventType] : undefined)
			});
			updateStatus(state, 'system', 'troubleType', {
				nr: troubleStatus,
				loc: pm.panelTroubleText[state.locale][troubleStatus],
				txt: (troubleStatus !== undefined ? pm.logEvent[state.locale][eventType] : undefined)
			});
			//luup.variable_set(PANEL_SID, "PanelStatusCode", string.format("%02X", logEvent), pmPanelDev)
			//luup.variable_set(PANEL_SID, "PanelStatusData", s, pmPanelDev)
			//luup.variable_set(PANEL_SID, "PanelAlarmType", alarmStatus, pmPanelDev)
			//luup.variable_set(PANEL_SID, "PanelTroubleType", troubleStatus, pmPanelDev)
			//luup.variable_set(PARTITION_SID, "LastUser", pmLogUser_t[eventZone + 1], pmPartitionDev_t[1])
			// Update siren status
			/*
			var noSiren = ((eventType == 0x0B) || (eventType == 0x0C)) && (state.silentPanic == true);
			if (alarmStatus != 'None') && (eventType != 0x04) && (noSiren == false) {
				for (var i = 1; i <= #pmSirenDev_t; i++) {
					luup.variable_set(SIREN_SID, "Status", "1", pmSirenDev_t[i])
				}
				pmSirenActive = pmTimeFunction() + 60 * pmBellTime
			}
			if (eventType == 0x1B) and (pmSirenActive != null) { // Cancel Alarm
				pmSirenActive = null
				for (var i = 1; i <= #pmSirenDev_t; i++) {
					luup.variable_set(SIREN_SID, "Status", "0", pmSirenDev_t[i])
				}
			}
			*/
			if (eventType == 0x60) { // System reset
				state.startDownload();
			}
		}
		return true, true // A7 always unexpected
	},

	// pmHandlePowerlink (0xAB)
	handlePowerlink: function(state) {
		var subType = state.incomingPdu[2];
		if (subType == 0x03) { // keepalive message
			state.sendAck(0x02);
			if (state.powerlinkMode == false) {
				state.debug("Got alive message while not in Powerlink mode; starting download")
				state.startDownload();
			}
				return true, true; // ignore alive message for expected response (never expected)
	   } else if (subType == 0x05) { // phone message
			var action = state.incomingPdu[4];
			/*
			if (action == 1) {
				pmUserMessage("CALL_USER", state.userCalling, pmPhoneNr_t[state.userCalling])
				state.userCalling += 1;
				if (state.userCalling > #pmPhoneNr_t) {
					state.userCalling = 1
				}
			} else if (action == 2) {
				pmUserMessage("CALL_ACK", state.userCalling)
				state.userCalling = 1
			}
			*/
			state.sendAck(0x02);
	   } else if (subType == 0x0A && state.incomingPdu[4] == 0x01) {
			state.debug("Enrolling Powerlink")
			state.sendMessage("MSG_ENROLL", { code: pm.secret }, true);
			//state.expectedResponse = [0xAB, 0x02, 0xA5].concat(state.expectedResponse.slice(1));
			state.expectedResponse = [0xAB, 0x02].concat(state.expectedResponse.slice(1));
			// TODO: only start download if panelType > 4 (but how?!)
			state.startDownload();
	   } else {
			state.sendAck(0x02);
	   }
	   return true
	},

	// handlePowerMaster (0xB0)
	handlePowerMaster: function(state) {
	   var msgSubTypes = [ 0x00, 0x01, 0x02, 0x03, 0x04, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
		  0x18, 0x19, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x24, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x38, 0x39, 0x3A ];
	   var msgType = state.incomingPdu[2]; // 00, 01, 04: req; 03: reply, so expecting 0x03
	   var subType = state.incomingPdu[3];
	   var msgLen = state.incomingPdu[4];
	   state.debug('Received PowerMaster message ' + msgType.toString(16) + '/' + subType.toString(16) + ' (len = ' + msgLen + ')');
	   return true
	}
}
